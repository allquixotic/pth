/* pth_p.h -- Generated for meson build */

/*
**  GNU Pth - The GNU Portable Threads
**  Copyright (c) 1999-2006 Ralf S. Engelschall <rse@engelschall.com>
**
**  This file is part of GNU Pth, a non-preemptive thread scheduling
**  library which can be found at http://www.gnu.org/software/pth/.
**
**  This library is free software; you can redistribute it and/or
**  modify it under the terms of the GNU Lesser General Public
**  License as published by the Free Software Foundation; either
**  version 2.1 of the License, or (at your option) any later version.
**
**  This library is distributed in the hope that it will be useful,
**  but WITHOUT ANY WARRANTY; without even the implied warranty of
**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
**  Lesser General Public License for more details.
**
**  You should have received a copy of the GNU Lesser General Public
**  License along with this library; if not, write to the Free Software
**  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
**  USA, or contact Ralf S. Engelschall <rse@engelschall.com>.
**
**  pth_p.h: Pth private API definitions
*/

#ifndef _PTH_P_H_
#define _PTH_P_H_

/* mandatory system headers */
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <stdint.h>
#include <string.h>
#include <setjmp.h>
#include <signal.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <ctype.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <time.h>

/* library version */
#define _PTH_VERS_C_AS_HEADER_
#include "pth_vers.c"
#undef  _PTH_VERS_C_AS_HEADER_

/* public API headers */
#define _PTH_PRIVATE
#include "pth.h"
#undef _PTH_PRIVATE

/* autoconf defines and macros */
#include "pth_acdef.h"
#include "pth_acmac.h"

/* optional system headers */
#ifdef HAVE_SYS_RESOURCE_H
#include <sys/resource.h>
#endif
#ifdef HAVE_NET_ERRNO_H
#include <net/errno.h>
#endif
#ifdef HAVE_DLFCN_H
#include <dlfcn.h>
#endif

/* dmalloc support */
#ifdef PTH_DMALLOC
#include <dmalloc.h>
#endif

/* OSSP ex support */
#ifdef PTH_EX
#define __EX_NS_USE_CUSTOM__
#include "ex.h"
#endif

/* paths */
#ifdef HAVE_PATHS_H
#include <paths.h>
#endif
#ifdef _PATH_BSHELL
#define PTH_PATH_BINSH _PATH_BSHELL
#else
#define PTH_PATH_BINSH "/bin/sh"
#endif

/* non-blocking flags */
#define O_NONBLOCKING O_NONBLOCK

/* FD_SETSIZE and struct timespec are available on modern Linux systems */

/* compiler happyness: avoid ``empty compilation unit'' problem */
#define COMPILER_HAPPYNESS(name) \
    int __##name##_unit = 0;

/* generated contents */

#endif /* _PTH_P_H_ */


/* Extracted definitions from source files */

enum {
    PTH_ATTR_GET,
    PTH_ATTR_SET
};
struct pth_attr_st {
    pth_t        a_tid;
    int          a_prio;
    int          a_dispatches;
    char         a_name[PTH_TCB_NAMELEN];
    int          a_joinable;
    unsigned int a_cancelstate;
    unsigned int a_stacksize;
    char        *a_stackaddr;
};
typedef struct pth_cleanup_st pth_cleanup_t;
struct pth_cleanup_st {
    pth_cleanup_t *next;
    void (*func)(void *);
    void *arg;
};
#ifndef PTH_DEBUG
#define pth_debug1(a1)                     /* NOP */
#define pth_debug2(a1, a2)                 /* NOP */
#define pth_debug3(a1, a2, a3)             /* NOP */
#define pth_debug4(a1, a2, a3, a4)         /* NOP */
#define pth_debug5(a1, a2, a3, a4, a5)     /* NOP */
#define pth_debug6(a1, a2, a3, a4, a5, a6) /* NOP */
#else
#define pth_debug1(a1)                     pth_debug(__FILE__, __LINE__, 1, a1)
#define pth_debug2(a1, a2)                 pth_debug(__FILE__, __LINE__, 2, a1, a2)
#define pth_debug3(a1, a2, a3)             pth_debug(__FILE__, __LINE__, 3, a1, a2, a3)
#define pth_debug4(a1, a2, a3, a4)         pth_debug(__FILE__, __LINE__, 4, a1, a2, a3, a4)
#define pth_debug5(a1, a2, a3, a4, a5)     pth_debug(__FILE__, __LINE__, 5, a1, a2, a3, a4, a5)
#define pth_debug6(a1, a2, a3, a4, a5, a6) pth_debug(__FILE__, __LINE__, 6, a1, a2, a3, a4, a5, a6)
#endif /* PTH_DEBUG */
/* enclose errno in a block */
#define pth_shield \
        for ( pth_errno_storage = errno, \
              pth_errno_flag = TRUE; \
              pth_errno_flag; \
              errno = pth_errno_storage, \
              pth_errno_flag = FALSE )
/* return plus setting an errno value */
#if defined(PTH_DEBUG)
#define pth_error(return_val,errno_val) \
        (errno = (errno_val), \
        pth_debug4("return 0x%lx with errno %d(\"%s\")", \
                   (unsigned long)(return_val), (errno), strerror((errno))), \
        (return_val))
#else
#define pth_error(return_val,errno_val) \
        (errno = (errno_val), (return_val))
#endif
/* pre-declare type of function event callback
   (mainly to workaround va_arg(3) problems below) */
typedef int (*pth_event_func_t)(void *);
/* event structure */
struct pth_event_st {
    struct pth_event_st *ev_next;
    struct pth_event_st *ev_prev;
    pth_status_t ev_status;
    int ev_type;
    int ev_goal;
    union {
        struct { int fd; }                                          FD;
        struct { int *n; int nfd; fd_set *rfds, *wfds, *efds; }     SELECT;
        struct { sigset_t *sigs; int *sig; }                        SIGS;
        struct { pth_time_t tv; }                                   TIME;
        struct { pth_msgport_t mp; }                                MSG;
        struct { pth_mutex_t *mutex; }                              MUTEX;
        struct { pth_cond_t *cond; }                                COND;
        struct { pth_t tid; }                                       TID;
        struct { pth_event_func_t func; void *arg; pth_time_t tv; } FUNC;
    } ev_args;
};
#define pth_implicit_init() \
    if (!pth_initialized) \
        pth_init();
#endif
#ifdef PTH_EX
/* exception handling callback functions */
static ex_ctx_t *pth_ex_ctx(void)
{
    return &(pth_current->ex_ctx);
}
static void pth_ex_terminate(ex_t *ex)
{
    pth_exit(ex->ex_value);
}
#endif
/* initialize the package */
int pth_init(void)
{
    pth_attr_t t_attr;
    /* support for implicit initialization calls
       and to prevent multiple explict initialization, too */
        return pth_error(FALSE, EPERM);
    }
    pth_initialized = TRUE;
    pth_debug1("pth_init: enter");
    /* initialize syscall wrapping */
    pth_syscall_init();
    /* initialize the scheduler */
        pth_shield { pth_syscall_kill(); }
        return pth_error(FALSE, EAGAIN);
    }
#ifdef PTH_EX
    /* optional support for exceptional handling */
    __ex_ctx       = pth_ex_ctx;
    __ex_terminate = pth_ex_terminate;
#endif
    /* spawn the scheduler thread */
    t_attr = pth_attr_new();
    pth_attr_set(t_attr, PTH_ATTR_PRIO,         PTH_PRIO_MAX);
    pth_attr_set(t_attr, PTH_ATTR_NAME,         "**SCHEDULER**");
    pth_attr_set(t_attr, PTH_ATTR_JOINABLE,     FALSE);
    pth_attr_set(t_attr, PTH_ATTR_CANCEL_STATE, PTH_CANCEL_DISABLE);
    pth_attr_set(t_attr, PTH_ATTR_STACK_SIZE,   65536);
    pth_attr_set(t_attr, PTH_ATTR_STACK_ADDR,   NULL);
    pth_sched = pth_spawn(t_attr, pth_scheduler, NULL);
        pth_shield {
            pth_attr_destroy(t_attr);
            pth_scheduler_kill();
            pth_syscall_kill();
        }
        return FALSE;
    }
    /* spawn a thread for the main program */
    pth_attr_set(t_attr, PTH_ATTR_PRIO,         PTH_PRIO_STD);
    pth_attr_set(t_attr, PTH_ATTR_NAME,         "main");
    pth_attr_set(t_attr, PTH_ATTR_JOINABLE,     TRUE);
    pth_attr_set(t_attr, PTH_ATTR_CANCEL_STATE, PTH_CANCEL_ENABLE|PTH_CANCEL_DEFERRED);
    pth_attr_set(t_attr, PTH_ATTR_STACK_SIZE,   0 /* special */);
    pth_attr_set(t_attr, PTH_ATTR_STACK_ADDR,   NULL);
    pth_main = pth_spawn(t_attr, (void *(*)(void *))(-1), NULL);
        pth_shield {
            pth_attr_destroy(t_attr);
            pth_scheduler_kill();
            pth_syscall_kill();
        }
        return FALSE;
    }
    pth_attr_destroy(t_attr);
    /*
     * The first time we've to manually switch into the scheduler to start
     * threading. Because at this time the only non-scheduler thread is the
     * "main thread" we will come back immediately. We've to also initialize
     * the pth_current variable here to allow the pth_spawn_trampoline
     * function to find the scheduler.
     */
    pth_current = pth_sched;
    pth_mctx_switch(&pth_main->mctx, &pth_sched->mctx);
    /* came back, so let's go home... */
    pth_debug1("pth_init: leave");
    return TRUE;
}
/* kill the package internals */
int pth_kill(void)
{
        return pth_error(FALSE, EINVAL);
    }
        return pth_error(FALSE, EPERM);
    }
    pth_debug1("pth_kill: enter");
    pth_thread_cleanup(pth_main);
    pth_scheduler_kill();
    pth_initialized = FALSE;
    pth_tcb_free(pth_sched);
    pth_tcb_free(pth_main);
    pth_syscall_kill();
#ifdef PTH_EX
    __ex_ctx       = __ex_ctx_default;
    __ex_terminate = __ex_terminate_default;
#endif
    pth_debug1("pth_kill: leave");
    return TRUE;
}
/* scheduler control/query */
long pth_ctrl(unsigned long query, ...)
{
    long rc;
    va_list ap;
    rc = 0;
    va_start(ap, query);
        if (query & PTH_CTRL_GETTHREADS_NEW)
            rc += pth_pqueue_elements(&pth_NQ);
        if (query & PTH_CTRL_GETTHREADS_READY)
            rc += pth_pqueue_elements(&pth_RQ);
        if (query & PTH_CTRL_GETTHREADS_RUNNING)
            rc += 1; /* pth_current only */
        if (query & PTH_CTRL_GETTHREADS_WAITING)
            rc += pth_pqueue_elements(&pth_WQ);
        if (query & PTH_CTRL_GETTHREADS_SUSPENDED)
            rc += pth_pqueue_elements(&pth_SQ);
        if (query & PTH_CTRL_GETTHREADS_DEAD)
            rc += pth_pqueue_elements(&pth_DQ);
    }
        float *pload = va_arg(ap, float *);
        *pload = pth_loadval;
    }
        pth_t t = va_arg(ap, pth_t);
        rc = t->prio;
    }
        pth_t t = va_arg(ap, pth_t);
        rc = (long)t->name;
    }
        FILE *fp = va_arg(ap, FILE *);
        pth_dumpstate(fp);
    }
        int favournew = va_arg(ap, int);
        pth_favournew = (favournew ? 1 : 0);
    }
    else
        rc = -1;
    va_end(ap);
    if (rc == -1)
        return pth_error(-1, EINVAL);
    return rc;
}
/* create a new thread of execution by spawning a cooperative thread */
static void pth_spawn_trampoline(void)
{
    void *data;
    /* just jump into the start routine */
    data = (*pth_current->start_func)(pth_current->start_arg);
    /* and do an implicit exit of the thread with the result value */
    pth_exit(data);
    /* NOTREACHED */
    abort();
}
pth_t pth_spawn(pth_attr_t attr, void *(*func)(void *), void *arg)
{
    pth_t t;
    unsigned int stacksize;
    void *stackaddr;
    pth_time_t ts;
    pth_debug1("pth_spawn: enter");
    /* consistency */
    if (func == NULL)
        return pth_error((pth_t)NULL, EINVAL);
    /* support the special case of main() */
    if (func == (void *(*)(void *))(-1))
        func = NULL;
    /* allocate a new thread control block */
    stacksize = (attr == PTH_ATTR_DEFAULT ? 64*1024 : attr->a_stacksize);
    stackaddr = (attr == PTH_ATTR_DEFAULT ? NULL    : attr->a_stackaddr);
    if ((t = pth_tcb_alloc(stacksize, stackaddr)) == NULL)
        return pth_error((pth_t)NULL, errno);
    /* configure remaining attributes */
        /* overtake fields from the attribute structure */
        t->prio        = attr->a_prio;
        t->joinable    = attr->a_joinable;
        t->cancelstate = attr->a_cancelstate;
        t->dispatches  = attr->a_dispatches;
        pth_util_cpystrn(t->name, attr->a_name, PTH_TCB_NAMELEN);
    }
        /* overtake some fields from the parent thread */
        t->prio        = pth_current->prio;
        t->joinable    = pth_current->joinable;
        t->cancelstate = pth_current->cancelstate;
        t->dispatches  = 0;
        pth_snprintf(t->name, PTH_TCB_NAMELEN, "%s.child@%d=0x%lx",
                     pth_current->name, (unsigned int)time(NULL),
                     (unsigned long)pth_current);
    }
    else {
        /* defaults */
        t->prio        = PTH_PRIO_STD;
        t->joinable    = TRUE;
        t->cancelstate = PTH_CANCEL_DEFAULT;
        t->dispatches  = 0;
        pth_snprintf(t->name, PTH_TCB_NAMELEN,
                     "user/%x", (unsigned int)time(NULL));
    }
    /* initialize the time points and ranges */
    pth_time_set(&ts, PTH_TIME_NOW);
    pth_time_set(&t->spawned, &ts);
    pth_time_set(&t->lastran, &ts);
    pth_time_set(&t->running, PTH_TIME_ZERO);
    /* initialize events */
    t->events = NULL;
    /* clear raised signals */
    sigemptyset(&t->sigpending);
    t->sigpendcnt = 0;
    /* remember the start routine and arguments for our trampoline */
    t->start_func = func;
    t->start_arg  = arg;
    /* initialize join argument */
    t->join_arg = NULL;
    /* initialize thread specific storage */
    t->data_value = NULL;
    t->data_count = 0;
    /* initialize cancellation stuff */
    t->cancelreq   = FALSE;
    t->cleanups    = NULL;
    /* initialize mutex stuff */
    pth_ring_init(&t->mutexring);
#ifdef PTH_EX
    /* initialize exception handling context */
    EX_CTX_INITIALIZE(&t->ex_ctx);
#endif
    /* initialize the machine context of this new thread */
        if (!pth_mctx_set(&t->mctx, pth_spawn_trampoline,
            pth_shield { pth_tcb_free(t); }
            return pth_error((pth_t)NULL, errno);
        }
    }
    /* finally insert it into the "new queue" where
       the scheduler will pick it up for dispatching */
        t->state = PTH_STATE_NEW;
        pth_pqueue_insert(&pth_NQ, t->prio, t);
    }
    pth_debug1("pth_spawn: leave");
    /* the returned thread id is just the pointer
       to the thread control block... */
    return t;
}
/* returns the current thread */
pth_t pth_self(void)
{
    return pth_current;
}
/* raise a signal for a thread */
int pth_raise(pth_t t, int sig)
{
    struct sigaction sa;
    if (t == NULL || t == pth_current || (sig < 0 || sig > PTH_NSIG))
        return pth_error(FALSE, EINVAL);
    if (sig == 0)
        /* just test whether thread exists */
        return pth_thread_exists(t);
    else {
        /* raise signal for thread */
        if (sigaction(sig, NULL, &sa) != 0)
            return FALSE;
        if (sa.sa_handler == SIG_IGN)
            return TRUE; /* fine, nothing to do, sig is globally ignored */
            sigaddset(&t->sigpending, sig);
            t->sigpendcnt++;
        }
        pth_yield(t);
        return TRUE;
    }
}
/* check whether a thread exists */
intern int pth_thread_exists(pth_t t)
{
    if (!pth_pqueue_contains(&pth_NQ, t))
        if (!pth_pqueue_contains(&pth_RQ, t))
            if (!pth_pqueue_contains(&pth_WQ, t))
                if (!pth_pqueue_contains(&pth_SQ, t))
                    if (!pth_pqueue_contains(&pth_DQ, t))
                        return pth_error(FALSE, ESRCH); /* not found */
    return TRUE;
}
/* cleanup a particular thread */
intern void pth_thread_cleanup(pth_t thread)
{
    /* run the cleanup handlers */
    if (thread->cleanups != NULL)
        pth_cleanup_popall(thread, TRUE);
    /* run the specific data destructors */
    if (thread->data_value != NULL)
        pth_key_destroydata(thread);
    /* release still acquired mutex variables */
    pth_mutex_releaseall(thread);
    return;
}
/* terminate the current thread */
static int pth_exit_cb(void *arg)
{
    (void)arg;
    int rc;
    /* BE CAREFUL HERE: THIS FUNCTION EXECUTES
       FROM WITHIN THE _SCHEDULER_ THREAD! */
    /* calculate number of still existing threads in system. Only
       skipped queue is pth_DQ (dead queue). This queue does not
       count here, because those threads are non-detached but already
       terminated ones -- and if we are the only remaining thread (which
       also wants to terminate and not join those threads) we can signal
       us through the scheduled event (for which we are running as the
       test function inside the scheduler) that the whole process can
       terminate now. */
    rc = 0;
    rc += pth_pqueue_elements(&pth_NQ);
    rc += pth_pqueue_elements(&pth_RQ);
    rc += pth_pqueue_elements(&pth_WQ);
    rc += pth_pqueue_elements(&pth_SQ);
    if (rc == 1 /* just our main thread */)
        return TRUE;
    else
        return FALSE;
}
void pth_exit(void *value)
{
    pth_event_t ev;
    pth_debug2("pth_exit: marking thread \"%s\" as dead", pth_current->name);
    /* the main thread is special, because its termination
       would terminate the whole process, so we have to delay 
       its termination until it is really the last thread */
            ev = pth_event(PTH_EVENT_FUNC, pth_exit_cb);
            pth_wait(ev);
            pth_event_free(ev, PTH_FREE_THIS);
        }
    }
    /* execute cleanups */
    pth_thread_cleanup(pth_current);
        /*
         * Now mark the current thread as dead, explicitly switch into the
         * scheduler and let it reap the current thread structure; we can't
         * free it here, or we'd be running on a stack which malloc() regards
         * as free memory, which would be a somewhat perilous situation.
         */
        pth_current->join_arg = value;
        pth_current->state = PTH_STATE_DEAD;
        pth_debug2("pth_exit: switching from thread \"%s\" to scheduler", pth_current->name);
        pth_mctx_switch(&pth_current->mctx, &pth_sched->mctx);
    }
    else {
        /*
         * main thread is special: exit the _process_
         * [double-casted to avoid warnings because of size]
         */
        pth_kill();
        exit((int)((long)value));
    }
    /* NOTREACHED */
    abort();
}
/* waits for the termination of the specified thread */
int pth_join(pth_t tid, void **value)
{
    pth_event_t ev;
    static pth_key_t ev_key = PTH_KEY_INIT;
    pth_debug2("pth_join: joining thread \"%s\"", tid == NULL ? "-ANY-" : tid->name);
    if (tid == pth_current)
        return pth_error(FALSE, EDEADLK);
    if (tid != NULL && !tid->joinable)
        return pth_error(FALSE, EINVAL);
    if (pth_ctrl(PTH_CTRL_GETTHREADS) == 1)
        return pth_error(FALSE, EDEADLK);
    if (tid == NULL)
        tid = pth_pqueue_head(&pth_DQ);
        ev = pth_event(PTH_EVENT_TID|PTH_UNTIL_TID_DEAD|PTH_MODE_STATIC, &ev_key, tid);
        pth_wait(ev);
    }
    if (tid == NULL)
        tid = pth_pqueue_head(&pth_DQ);
    if (tid == NULL || (tid != NULL && tid->state != PTH_STATE_DEAD))
        return pth_error(FALSE, EIO);
    if (value != NULL)
        *value = tid->join_arg;
    pth_pqueue_delete(&pth_DQ, tid);
    pth_tcb_free(tid);
    return TRUE;
}
/* delegates control back to scheduler for context switches */
int pth_yield(pth_t to)
{
    pth_pqueue_t *q = NULL;
    pth_debug2("pth_yield: enter from thread \"%s\"", pth_current->name);
    /* a given thread has to be new or ready or we ignore the request */
            case PTH_STATE_NEW:    q = &pth_NQ; break;
            case PTH_STATE_READY:  q = &pth_RQ; break;
            default:               q = NULL;
        }
        if (q == NULL || !pth_pqueue_contains(q, to))
            return pth_error(FALSE, EINVAL);
    }
    /* give a favored thread maximum priority in his queue */
    if (to != NULL && q != NULL)
        pth_pqueue_favorite(q, to);
    /* switch to scheduler */
    if (to != NULL)
        pth_debug2("pth_yield: give up control to scheduler "
                   "in favour of thread \"%s\"", to->name);
    else
        pth_debug1("pth_yield: give up control to scheduler");
    pth_mctx_switch(&pth_current->mctx, &pth_sched->mctx);
    pth_debug1("pth_yield: got back control from scheduler");
    pth_debug2("pth_yield: leave to thread \"%s\"", pth_current->name);
    return TRUE;
}
/* suspend a thread until its again manually resumed */
int pth_suspend(pth_t t)
{
    pth_pqueue_t *q;
    if (t == NULL)
        return pth_error(FALSE, EINVAL);
    if (t == pth_sched || t == pth_current)
        return pth_error(FALSE, EPERM);
        case PTH_STATE_NEW:     q = &pth_NQ; break;
        case PTH_STATE_READY:   q = &pth_RQ; break;
        case PTH_STATE_WAITING: q = &pth_WQ; break;
        default:                q = NULL;
    }
    if (q == NULL)
        return pth_error(FALSE, EPERM);
    if (!pth_pqueue_contains(q, t))
        return pth_error(FALSE, ESRCH);
    pth_pqueue_delete(q, t);
    pth_pqueue_insert(&pth_SQ, PTH_PRIO_STD, t);
    pth_debug2("pth_suspend: suspend thread \"%s\"\n", t->name);
    return TRUE;
}
/* resume a previously suspended thread */
int pth_resume(pth_t t)
{
    pth_pqueue_t *q;
    if (t == NULL)
        return pth_error(FALSE, EINVAL);
    if (t == pth_sched || t == pth_current)
        return pth_error(FALSE, EPERM);
    if (!pth_pqueue_contains(&pth_SQ, t))
        return pth_error(FALSE, EPERM);
    pth_pqueue_delete(&pth_SQ, t);
        case PTH_STATE_NEW:     q = &pth_NQ; break;
        case PTH_STATE_READY:   q = &pth_RQ; break;
        case PTH_STATE_WAITING: q = &pth_WQ; break;
        default:                q = NULL;
    }
    pth_pqueue_insert(q, PTH_PRIO_STD, t);
    pth_debug2("pth_resume: resume thread \"%s\"\n", t->name);
    return TRUE;
}
/* switch a filedescriptor's I/O mode */
int pth_fdmode(int fd, int newmode)
{
    int fdmode;
    int oldmode;
    /* retrieve old mode (usually a very cheap operation) */
    if ((fdmode = fcntl(fd, F_GETFL, NULL)) == -1)
        oldmode = PTH_FDMODE_ERROR;
    else if (fdmode & O_NONBLOCKING)
        oldmode = PTH_FDMODE_NONBLOCK;
    else
        oldmode = PTH_FDMODE_BLOCK;
    /* set new mode (usually a more expensive operation) */
    if (oldmode == PTH_FDMODE_BLOCK && newmode == PTH_FDMODE_NONBLOCK)
        fcntl(fd, F_SETFL, (fdmode | O_NONBLOCKING));
    if (oldmode == PTH_FDMODE_NONBLOCK && newmode == PTH_FDMODE_BLOCK)
        fcntl(fd, F_SETFL, (fdmode & ~(O_NONBLOCKING)));
    /* return old mode */
    return oldmode;
}
/* wait for specific amount of time */
int pth_nap(pth_time_t naptime)
{
    pth_time_t until;
    pth_event_t ev;
    static pth_key_t ev_key = PTH_KEY_INIT;
    if (pth_time_cmp(&naptime, PTH_TIME_ZERO) == 0)
        return pth_error(FALSE, EINVAL);
    pth_time_set(&until, PTH_TIME_NOW);
    pth_time_add(&until, &naptime);
    ev = pth_event(PTH_EVENT_TIME|PTH_MODE_STATIC, &ev_key, until);
    pth_wait(ev);
    return TRUE;
}
/* runs a constructor once */
int pth_once(pth_once_t *oncectrl, void (*constructor)(void *), void *arg)
{
    if (oncectrl == NULL || constructor == NULL)
        return pth_error(FALSE, EINVAL);
    if (*oncectrl != TRUE)
        constructor(arg);
    *oncectrl = TRUE;
    return TRUE;
}
/*
 * machine context state structure
 *
 * In `jb' the CPU registers, the program counter, the stack
 * pointer and (usually) the signals mask is stored. When the
 * signal mask cannot be implicitly stored in `jb', it's
 * alternatively stored explicitly in `sigs'. The `error' stores
 * the value of `errno'.
 */
#if PTH_MCTX_MTH(mcsc)
#include <ucontext.h>
#endif
typedef struct pth_mctx_st pth_mctx_t;
struct pth_mctx_st {
#if PTH_MCTX_MTH(mcsc)
    ucontext_t uc;
    int restored;
#elif PTH_MCTX_MTH(sjlj)
    pth_sigjmpbuf jb;
#else
#error "unknown mctx method"
#endif
    sigset_t sigs;
#if PTH_MCTX_DSP(sjlje)
    sigset_t block;
#endif
    int error;
};
/*
** ____ MACHINE STATE SWITCHING ______________________________________
*/
/*
 * save the current machine context
 */
#if PTH_MCTX_MTH(mcsc)
#define pth_mctx_save(mctx) \
        ( (mctx)->error = errno, \
          (mctx)->restored = 0, \
          getcontext(&(mctx)->uc), \
          (mctx)->restored )
#elif PTH_MCTX_MTH(sjlj) && PTH_MCTX_DSP(sjlje)
#define pth_mctx_save(mctx) \
        ( (mctx)->error = errno, \
          pth_sc(sigprocmask)(SIG_SETMASK, &((mctx)->block), NULL), \
          pth_sigsetjmp((mctx)->jb) )
#elif PTH_MCTX_MTH(sjlj)
#define pth_mctx_save(mctx) \
        ( (mctx)->error = errno, \
          pth_sigsetjmp((mctx)->jb) )
#else
#error "unknown mctx method"
#endif
/*
 * restore the current machine context
 * (at the location of the old context)
 */
#if PTH_MCTX_MTH(mcsc)
#define pth_mctx_restore(mctx) \
        ( errno = (mctx)->error, \
          (mctx)->restored = 1, \
          (void)setcontext(&(mctx)->uc) )
#elif PTH_MCTX_MTH(sjlj)
#define pth_mctx_restore(mctx) \
        ( errno = (mctx)->error, \
          (void)pth_siglongjmp((mctx)->jb, 1) )
#else
#error "unknown mctx method"
#endif
/*
 * restore the current machine context
 * (at the location of the new context)
 */
#if PTH_MCTX_MTH(sjlj) && PTH_MCTX_DSP(sjlje)
#define pth_mctx_restored(mctx) \
        pth_sc(sigprocmask)(SIG_SETMASK, &((mctx)->sigs), NULL)
#else
#define pth_mctx_restored(mctx) \
        /*nop*/
#endif
/*
 * switch from one machine context to another
 */
#define SWITCH_DEBUG_LINE \
        "==== THREAD CONTEXT SWITCH ==========================================="
#ifdef PTH_DEBUG
#define  _pth_mctx_switch_debug pth_debug(NULL, 0, 1, SWITCH_DEBUG_LINE);
#else
#define  _pth_mctx_switch_debug /*NOP*/
#endif
#if PTH_MCTX_MTH(mcsc)
#define pth_mctx_switch(old,new) \
    _pth_mctx_switch_debug \
    swapcontext(&((old)->uc), &((new)->uc));
#elif PTH_MCTX_MTH(sjlj)
#define pth_mctx_switch(old,new) \
    _pth_mctx_switch_debug \
    if (pth_mctx_save(old) == 0) \
        pth_mctx_restore(new); \
    pth_mctx_restored(old);
#else
#error "unknown mctx method"
#endif
/* message port structure */
struct pth_msgport_st {
    pth_ringnode_t mp_node;  /* maintainance node handle */
    const char    *mp_name;  /* optional name of message port */
    pth_t          mp_tid;   /* corresponding thread */
    pth_ring_t     mp_queue; /* queue of messages pending on port */
};
/* thread priority queue */
struct pth_pqueue_st {
    pth_t q_head;
    int   q_num;
};
typedef struct pth_pqueue_st pth_pqueue_t;
#define pth_pqueue_favorite_prio(q) \
    ((q)->q_head != NULL ? (q)->q_head->q_prio + 1 : PTH_PRIO_MAX)
#endif
/* move a thread inside queue to the top; O(n) */
intern int pth_pqueue_favorite(pth_pqueue_t *q, pth_t t)
{
    if (q == NULL)
        return FALSE;
    if (q->q_head == NULL || q->q_num == 0)
        return FALSE;
    /* element is already at top */
    if (q->q_num == 1)
        return TRUE;
    /* move to top */
    pth_pqueue_delete(q, t);
    pth_pqueue_insert(q, pth_pqueue_favorite_prio(q), t);
    return TRUE;
}
/* increase priority of all(!) threads in queue; O(1) */
intern void pth_pqueue_increase(pth_pqueue_t *q)
{
    if (q == NULL)
        return;
    if (q->q_head == NULL)
        return;
    /* <grin> yes, that's all ;-) */
    q->q_head->q_prio += 1;
    return;
}
/* return number of elements in priority queue: O(1) */
#define pth_pqueue_elements(q) \
    ((q) == NULL ? (-1) : (q)->q_num)
#endif
/* walk to first thread in queue; O(1) */
#define pth_pqueue_head(q) \
    ((q) == NULL ? NULL : (q)->q_head)
#endif
/* walk to last thread in queue */
intern pth_t pth_pqueue_tail(pth_pqueue_t *q)
{
    if (q == NULL)
        return NULL;
    if (q->q_head == NULL)
        return NULL;
    return q->q_head->q_prev;
}
/* walk to next or previous thread in queue; O(1) */
intern pth_t pth_pqueue_walk(pth_pqueue_t *q, pth_t t, int direction)
{
    pth_t tn;
    if (q == NULL || t == NULL)
        return NULL;
    tn = NULL;
        if (t != q->q_head)
            tn = t->q_prev;
    }
        tn = t->q_next;
        if (tn == q->q_head)
            tn = NULL;
    }
    return tn;
}
/* check whether a thread is in a queue; O(n) */
intern int pth_pqueue_contains(pth_pqueue_t *q, pth_t t)
{
    pth_t tc;
    int found;
    found = FALSE;
    for (tc = pth_pqueue_head(q); tc != NULL;
            found = TRUE;
            break;
        }
    }
    return found;
}
#define pth_ring_elements(r) \
    ({ pth_ring_t *_r = (r); \
       int _result; \
       if (_r == NULL) \
           _result = -1; \
       else \
           _result = (int)(_r->r_nodes); \
       _result; })
#endif
/* return first node in ring; O(1) */
#define pth_ring_first(r) \
    ((r) == NULL ? NULL : (r)->r_hook)
#endif
/* return last node in ring; O(1) */
#define pth_ring_last(r) \
    ((r) == NULL ? NULL : ((r)->r_hook == NULL ? NULL : (r)->r_hook->rn_prev))
#endif
/* walk to next node in ring; O(1) */
#define pth_ring_next(r, rn) \
    (((r) == NULL || (rn) == NULL) ? NULL : ((rn)->rn_next == (r)->r_hook ? NULL : (rn)->rn_next))
#endif
/* walk to previous node in ring; O(1) */
#define pth_ring_prev(r, rn) \
    (((r) == NULL || (rn) == NULL) ? NULL : ((rn)->rn_prev == (r)->r_hook->rn_prev ? NULL : (rn)->rn_prev))
#endif
/* insert node into ring; O(1) */
#define pth_ring_insert(r, rn) \
    pth_ring_append((r), (rn))
#endif
/* insert node after a second node in ring; O(1) */
intern void pth_ring_insert_after(pth_ring_t *r, pth_ringnode_t *rn1, pth_ringnode_t *rn2)
{
    if (r == NULL || rn1 == NULL || rn2 == NULL)
        return;
    rn2->rn_prev = rn1;
    rn2->rn_next = rn1->rn_next;
    rn2->rn_prev->rn_next = rn2;
    rn2->rn_next->rn_prev = rn2;
    r->r_nodes++;
    return;
}
/* insert node before a second node in ring; O(1) */
intern void pth_ring_insert_before(pth_ring_t *r, pth_ringnode_t *rn1, pth_ringnode_t *rn2)
{
    if (r == NULL || rn1 == NULL || rn2 == NULL)
        return;
    rn2->rn_next = rn1;
    rn2->rn_prev = rn1->rn_prev;
    rn2->rn_prev->rn_next = rn2;
    rn2->rn_next->rn_prev = rn2;
    r->r_nodes++;
    return;
}
/* delete an node from ring; O(1) */
intern void pth_ring_delete(pth_ring_t *r, pth_ringnode_t *rn)
{
    if (r == NULL || rn == NULL)
        return;
    if (r->r_hook == rn && rn->rn_prev == rn && rn->rn_next == rn)
        r->r_hook = NULL;
    else {
        if (r->r_hook == rn)
            r->r_hook = rn->rn_next;
        rn->rn_prev->rn_next = rn->rn_next;
        rn->rn_next->rn_prev = rn->rn_prev;
    }
    r->r_nodes--;
    return;
}
/* prepend an node to ring; O(1) */
intern void pth_ring_prepend(pth_ring_t *r, pth_ringnode_t *rn)
{
    if (r == NULL || rn == NULL)
        return;
        r->r_hook = rn;
        rn->rn_next = rn;
        rn->rn_prev = rn;
    }
    else {
        rn->rn_next = r->r_hook;
        rn->rn_prev = r->r_hook->rn_prev;
        rn->rn_next->rn_prev = rn;
        rn->rn_prev->rn_next = rn;
        r->r_hook = rn;
    }
    r->r_nodes++;
    return;
}
/* append an node to ring; O(1) */
intern void pth_ring_append(pth_ring_t *r, pth_ringnode_t *rn)
{
    if (r == NULL || rn == NULL)
        return;
        r->r_hook = rn;
        rn->rn_next = rn;
        rn->rn_prev = rn;
    }
    else {
        rn->rn_next = r->r_hook;
        rn->rn_prev = r->r_hook->rn_prev;
        rn->rn_next->rn_prev = rn;
        rn->rn_prev->rn_next = rn;
    }
    r->r_nodes++;
    return;
}
/* treat ring as stack: push node onto stack; O(1) */
#define pth_ring_push(r, rn) \
    pth_ring_prepend((r), (rn))
#endif
/* treat ring as stack: pop node from stack; O(1) */
intern pth_ringnode_t *pth_ring_pop(pth_ring_t *r)
{
    pth_ringnode_t *rn;
    rn = pth_ring_first(r);
    if (rn != NULL)
        pth_ring_delete(r, rn);
    return rn;
}
/* treat ring as queue: favorite a node in the ring; O(1) */
intern int pth_ring_favorite(pth_ring_t *r, pth_ringnode_t *rn)
{
    if (r == NULL)
        return FALSE;
    if (r->r_hook == NULL)
        return FALSE;
    /* element is perhaps already at ring hook */
    if (r->r_hook == rn)
        return TRUE;
    /* move to hook of ring */
    pth_ring_delete(r, rn);
    pth_ring_prepend(r, rn);
    return TRUE;
}
/* treat ring as queue: enqueue node; O(1) */
#define pth_ring_enqueue(r, rn) \
    pth_ring_prepend((r), (rn))
#endif
/* treat ring as queue: dequeue node; O(1) */
intern pth_ringnode_t *pth_ring_dequeue(pth_ring_t *r)
{
    pth_ringnode_t *rn;
    rn = pth_ring_last(r);
    if (rn != NULL)
        pth_ring_delete(r, rn);
    return rn;
}
/* check whether node is contained in ring; O(n) */
intern int pth_ring_contains(pth_ring_t *r, pth_ringnode_t *rns)
{
    pth_ringnode_t *rn;
    int rc;
    if (r == NULL || rns == NULL)
        return pth_error(FALSE, EINVAL);
    rc = FALSE;
    rn = r->r_hook;
        do {
                rc = TRUE;
                break;
            }
            rn = rn->rn_next;
        } while (rn != r->r_hook);
    }
    return rc;
}
#if PTH_SYSCALL_HARD
/* hard syscall mapping */
#if HAVE_SYS_SYSCALL_H
#include <sys/syscall.h>
#endif
#ifdef HAVE_SYS_SOCKETCALL_H
#include <sys/socketcall.h>
#endif
#define pth_sc(func) pth_sc_##func
#else /* !PTH_SYSCALL_HARD */
/* no hard syscall mapping */
#define pth_sc(func) func
#endif /* PTH_SYSCALL_HARD */
typedef int (*pth_syscall_fct_t)();
typedef struct {
    char             *name;    /* name of system/function call */
    pth_syscall_fct_t addr;    /* address of wrapped system/function call */
} pth_syscall_fct_tab_t;
typedef struct {
    char             *path;    /* path to dynamic library */
    void             *handle;  /* handle of dynamic library */
} pth_syscall_lib_tab_t;
#endif
#if PTH_SYSCALL_HARD
/* NUL-spiked copy of library paths */
static char *pth_syscall_libs = NULL;
/* table of dynamic libraries and their resolving handles */
static pth_syscall_lib_tab_t pth_syscall_lib_tab[128] = {
    { NULL, NULL }
};
/* table of syscalls and their resolved function pointers */
intern pth_syscall_fct_tab_t pth_syscall_fct_tab[] = {
    /* Notice: order must match the macro values above */
#define PTH_SCF_fork          0
#define PTH_SCF_waitpid       1
#define PTH_SCF_system        2
#define PTH_SCF_nanosleep     3
#define PTH_SCF_usleep        4
#define PTH_SCF_sleep         5
#define PTH_SCF_sigprocmask   6
#define PTH_SCF_sigwait       7
#define PTH_SCF_select        8
#define PTH_SCF_poll          9
#define PTH_SCF_connect       10
#define PTH_SCF_accept        11
#define PTH_SCF_read          12
#define PTH_SCF_write         13
#define PTH_SCF_readv         14
#define PTH_SCF_writev        15
#define PTH_SCF_recv          16
#define PTH_SCF_send          17
#define PTH_SCF_recvfrom      18
#define PTH_SCF_sendto        19
#define PTH_SCF_pread         20
#define PTH_SCF_pwrite        21
    { "fork",        NULL },
    { "waitpid",     NULL },
    { "system",      NULL },
    { "nanosleep",   NULL },
    { "usleep",      NULL },
    { "sleep",       NULL },
    { "sigprocmask", NULL },
    { "sigwait",     NULL },
    { "select",      NULL },
    { "poll",        NULL },
    { "connect",     NULL },
    { "accept",      NULL },
    { "read",        NULL },
    { "write",       NULL },
    { "readv",       NULL },
    { "writev",      NULL },
    { "recv",        NULL },
    { "send",        NULL },
    { "recvfrom",    NULL },
    { "sendto",      NULL },
    { "pread",       NULL },
    { "pwrite",      NULL },
    { NULL,          NULL }
};
#endif
/* syscall wrapping initialization */
intern void pth_syscall_init(void)
{
#if PTH_SYSCALL_HARD
    int i;
    int j;
    char *cpLib;
    char *cp;
    /* fill paths of libraries into internal table */
    pth_syscall_libs = strdup(PTH_SYSCALL_LIBS);
    cpLib = pth_syscall_libs;
        if ((cp = strchr(cpLib, ':')) != NULL)
            *cp++ = '\0';
        pth_syscall_lib_tab[i].path   = cpLib;
        pth_syscall_lib_tab[i].handle = NULL;
        i++;
        if (cp != NULL)
            cpLib = cp;
        else
            break;
    }
    pth_syscall_lib_tab[i].path = NULL;
#if defined(HAVE_DLOPEN) && defined(HAVE_DLSYM)
    /* determine addresses of syscall functions */
        /* attempt #1: fetch from implicit successor libraries */
#if defined(HAVE_DLSYM) && defined(HAVE_RTLD_NEXT)
        pth_syscall_fct_tab[i].addr = (pth_syscall_fct_t)
            dlsym(RTLD_NEXT, pth_syscall_fct_tab[i].name);
#endif
        /* attempt #2: fetch from explicitly loaded C library */
            /* first iteration: try resolve from already loaded libraries */
                    pth_syscall_fct_tab[i].addr = (pth_syscall_fct_t)
                        dlsym(pth_syscall_lib_tab[j].handle,
                              pth_syscall_fct_tab[i].name);
                    if (pth_syscall_fct_tab[i].addr != NULL)
                        break;
                }
            }
            /* second iteration: try to load more libraries for resolving */
                        if ((pth_syscall_lib_tab[j].handle =
                             dlopen(pth_syscall_lib_tab[j].path, RTLD_LAZY)) == NULL)
                            continue;
                        pth_syscall_fct_tab[i].addr = (pth_syscall_fct_t)
                            dlsym(pth_syscall_lib_tab[j].handle,
                                  pth_syscall_fct_tab[i].name);
                        if (pth_syscall_fct_tab[i].addr != NULL)
                            break;
                    }
                }
            }
        }
    }
#endif
#endif
    return;
}
/* syscall wrapping initialization */
intern void pth_syscall_kill(void)
{
#if PTH_SYSCALL_HARD
    int i;
#if defined(HAVE_DLOPEN) && defined(HAVE_DLSYM)
    /* unload all explicitly loaded libraries */
            dlclose(pth_syscall_lib_tab[i].handle);
            pth_syscall_lib_tab[i].handle = NULL;
        }
        pth_syscall_lib_tab[i].path = NULL;
    }
#endif
    free(pth_syscall_libs);
    pth_syscall_libs = NULL;
#endif
    return;
}
#if PTH_SYSCALL_HARD
/* utility macro for returning syscall errors */
#define PTH_SYSCALL_ERROR(return_val,errno_val,syscall) \
    do { fprintf(stderr, \
                 "pth:WARNING: unable to perform syscall `%s': " \
                 "no implementation resolvable\n", syscall); \
         errno = (errno_val); \
         return (return_val); \
    } while (0)
/* ==== Pth hard syscall wrapper for fork(2) ==== */
pid_t fork(void);
pid_t fork(void)
{
    /* external entry point for application */
    pth_implicit_init();
    return pth_fork();
}
intern pid_t pth_sc_fork(void)
{
    /* internal exit point for Pth */
    if (pth_syscall_fct_tab[PTH_SCF_fork].addr != NULL)
        return ((pid_t (*)(void))
               pth_syscall_fct_tab[PTH_SCF_fork].addr)
               ();
#if defined(HAVE_SYSCALL) && defined(SYS_fork)
    else return (pid_t)syscall(SYS_fork);
#else
    else PTH_SYSCALL_ERROR(-1, ENOSYS, "fork");
#endif
}
/* ==== Pth hard syscall wrapper for nanosleep(3) ==== */
int nanosleep(const struct timespec *, struct timespec *);
int nanosleep(const struct timespec *rqtp, struct timespec *rmtp)
{
    /* external entry point for application */
    pth_implicit_init();
    return pth_nanosleep(rqtp, rmtp);
}
/* NOTICE: internally fully emulated, so still no
   internal exit point pth_sc_nanosleep necessary! */
/* ==== Pth hard syscall wrapper for usleep(3) ==== */
int usleep(unsigned int);
int usleep(unsigned int sec)
{
    /* external entry point for application */
    pth_implicit_init();
    return pth_usleep(sec);
}
/* NOTICE: internally fully emulated, so still no
   internal exit point pth_sc_usleep necessary! */
/* ==== Pth hard syscall wrapper for sleep(3) ==== */
unsigned int sleep(unsigned int);
unsigned int sleep(unsigned int sec)
{
    /* external entry point for application */
    pth_implicit_init();
    return pth_sleep(sec);
}
/* NOTICE: internally fully emulated, so still no
   internal exit point pth_sc_sleep necessary! */
/* ==== Pth hard syscall wrapper for system(3) ==== */
int system(const char *);
int system(const char *cmd)
{
    /* external entry point for application */
    pth_implicit_init();
    return pth_system(cmd);
}
/* NOTICE: internally fully emulated, so still no
   internal exit point pth_sc_system necessary! */
/* ==== Pth hard syscall wrapper for sigprocmask(2) ==== */
int sigprocmask(int, const sigset_t *, sigset_t *);
int sigprocmask(int how, const sigset_t *set, sigset_t *oset)
{
    /* external entry point for application */
    pth_implicit_init();
    return pth_sigmask(how, set, oset);
}
intern int pth_sc_sigprocmask(int how, const sigset_t *set, sigset_t *oset)
{
    /* internal exit point for Pth */
    if (pth_syscall_fct_tab[PTH_SCF_sigprocmask].addr != NULL)
        return ((int (*)(int, const sigset_t *, sigset_t *))
               pth_syscall_fct_tab[PTH_SCF_sigprocmask].addr)
               (how, set, oset);
#if defined(HAVE_SYSCALL) && defined(SYS___sigprocmask14) /* NetBSD */
    else return (int)syscall(SYS___sigprocmask14, how, set, oset);
#elif defined(HAVE_SYSCALL) && defined(SYS_sigprocmask)
    else return (int)syscall(SYS_sigprocmask, how, set, oset);
#else
    else PTH_SYSCALL_ERROR(-1, ENOSYS, "sigprocmask");
#endif
}
/* ==== Pth hard syscall wrapper for sigwait(3) ==== */
int sigwait(const sigset_t *, int *);
int sigwait(const sigset_t *set, int *sigp)
{
    /* external entry point for application */
    pth_implicit_init();
    return pth_sigwait(set, sigp);
}
/* NOTICE: internally fully emulated, so still no
   internal exit point pth_sc_sigwait necessary! */
/* ==== Pth hard syscall wrapper for waitpid(2) ==== */
pid_t waitpid(pid_t, int *, int);
pid_t waitpid(pid_t wpid, int *status, int options)
{
    /* external entry point for application */
    pth_implicit_init();
    return pth_waitpid(wpid, status, options);
}
intern pid_t pth_sc_waitpid(pid_t wpid, int *status, int options)
{
    /* internal exit point for Pth */
    if (pth_syscall_fct_tab[PTH_SCF_waitpid].addr != NULL)
        return ((pid_t (*)(pid_t, int *, int))
               pth_syscall_fct_tab[PTH_SCF_waitpid].addr)
               (wpid, status, options);
#if defined(HAVE_SYSCALL) && defined(SYS_waitpid)
    else return (pid_t)syscall(SYS_waitpid, wpid, status, options);
#else
    else PTH_SYSCALL_ERROR(-1, ENOSYS, "waitpid");
#endif
}
/* ==== Pth hard syscall wrapper for connect(2) ==== */
int connect(int, const struct sockaddr *, socklen_t);
int connect(int s, const struct sockaddr *addr, socklen_t addrlen)
{
    /* external entry point for application */
    pth_implicit_init();
    return pth_connect(s, addr, addrlen);
}
intern int pth_sc_connect(int s, const struct sockaddr *addr, socklen_t addrlen)
{
    /* internal exit point for Pth */
    if (pth_syscall_fct_tab[PTH_SCF_connect].addr != NULL)
        return ((int (*)(int, const struct sockaddr *, socklen_t))
               pth_syscall_fct_tab[PTH_SCF_connect].addr)
               (s, addr, addrlen);
#if defined(HAVE_SYSCALL) && defined(SYS_connect)
    else return (int)syscall(SYS_connect, s, addr, addrlen);
#elif defined(HAVE_SYSCALL) && defined(SYS_socketcall) && defined(SOCKOP_connect) /* Linux */
    else {
        unsigned long args[3];
        args[0] = (unsigned long)s;
        args[1] = (unsigned long)addr;
        args[2] = (unsigned long)addrlen;
        return (int)syscall(SYS_socketcall, SOCKOP_connect, args);
    }
#else
    else PTH_SYSCALL_ERROR(-1, ENOSYS, "connect");
#endif
}
/* ==== Pth hard syscall wrapper for accept(2) ==== */
int accept(int, struct sockaddr *, socklen_t *);
int accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
    /* external entry point for application */
    pth_implicit_init();
    return pth_accept(s, addr, addrlen);
}
intern int pth_sc_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
    /* internal exit point for Pth */
    if (pth_syscall_fct_tab[PTH_SCF_accept].addr != NULL)
        return ((int (*)(int, struct sockaddr *, socklen_t *))
               pth_syscall_fct_tab[PTH_SCF_accept].addr)
               (s, addr, addrlen);
#if defined(HAVE_SYSCALL) && defined(SYS_accept)
    else return (int)syscall(SYS_accept, s, addr, addrlen);
#elif defined(HAVE_SYSCALL) && defined(SYS_socketcall) && defined(SOCKOP_accept) /* Linux */
    else {
        unsigned long args[3];
        args[0] = (unsigned long)s;
        args[1] = (unsigned long)addr;
        args[2] = (unsigned long)addrlen;
        return (int)syscall(SYS_socketcall, SOCKOP_accept, args);
    }
#else
    else PTH_SYSCALL_ERROR(-1, ENOSYS, "accept");
#endif
}
/* ==== Pth hard syscall wrapper for select(2) ==== */
int select(int, fd_set *, fd_set *, fd_set *, struct timeval *);
int select(int nfds, fd_set *readfds, fd_set *writefds,
           fd_set *exceptfds, struct timeval *timeout)
{
    /* external entry point for application */
    pth_implicit_init();
    return pth_select(nfds, readfds, writefds, exceptfds, timeout);
}
intern int pth_sc_select(int nfds, fd_set *readfds, fd_set *writefds,
                         fd_set *exceptfds, struct timeval *timeout)
{
    /* internal exit point for Pth */
    if (pth_syscall_fct_tab[PTH_SCF_select].addr != NULL)
        return ((int (*)(int, fd_set *, fd_set *, fd_set *, struct timeval *))
               pth_syscall_fct_tab[PTH_SCF_select].addr)
               (nfds, readfds, writefds, exceptfds, timeout);
#if defined(HAVE_SYSCALL) && defined(SYS__newselect) /* Linux */
    else return (int)syscall(SYS__newselect, nfds, readfds, writefds, exceptfds, timeout);
#elif defined(HAVE_SYSCALL) && defined(SYS_select)
    else return (int)syscall(SYS_select, nfds, readfds, writefds, exceptfds, timeout);
#else
    else PTH_SYSCALL_ERROR(-1, ENOSYS, "accept");
#endif
}
/* ==== Pth hard syscall wrapper for pselect(2) ==== */
int pselect(int, fd_set *, fd_set *, fd_set *, const struct timespec *, const sigset_t *);
int pselect(int nfds, fd_set *rfds, fd_set *wfds, fd_set *efds,
            const struct timespec *ts, const sigset_t *mask)
{
    /* external entry point for application */
    pth_implicit_init();
    return pth_pselect(nfds, rfds, wfds, efds, ts, mask);
}
/* NOTICE: internally fully emulated, so still no
   internal exit point pth_sc_pselect necessary! */
/* ==== Pth hard syscall wrapper for poll(2) ==== */
int poll(struct pollfd *, nfds_t, int);
int poll(struct pollfd *pfd, nfds_t nfd, int timeout)
{
    /* external entry point for application */
    pth_implicit_init();
    return pth_poll(pfd, nfd, timeout);
}
/* NOTICE: internally fully emulated, so still no
   internal exit point pth_sc_poll necessary! */
/* ==== Pth hard syscall wrapper for read(2) ==== */
ssize_t read(int, void *, size_t);
ssize_t read(int fd, void *buf, size_t nbytes)
{
    /* external entry point for application */
    pth_implicit_init();
    return pth_read(fd, buf, nbytes);
}
intern ssize_t pth_sc_read(int fd, void *buf, size_t nbytes)
{
    /* internal exit point for Pth */
    if (pth_syscall_fct_tab[PTH_SCF_read].addr != NULL)
        return ((ssize_t (*)(int, void *, size_t))
               pth_syscall_fct_tab[PTH_SCF_read].addr)
               (fd, buf, nbytes);
#if defined(HAVE_SYSCALL) && defined(SYS_read)
    else return (ssize_t)syscall(SYS_read, fd, buf, nbytes);
#else
    else PTH_SYSCALL_ERROR(-1, ENOSYS, "read");
#endif
}
/* ==== Pth hard syscall wrapper for write(2) ==== */
ssize_t write(int, const void *, size_t);
ssize_t write(int fd, const void *buf, size_t nbytes)
{
    /* external entry point for application */
    pth_implicit_init();
    return pth_write(fd, buf, nbytes);
}
intern ssize_t pth_sc_write(int fd, const void *buf, size_t nbytes)
{
    /* internal exit point for Pth */
    if (pth_syscall_fct_tab[PTH_SCF_write].addr != NULL)
        return ((ssize_t (*)(int, const void *, size_t))
               pth_syscall_fct_tab[PTH_SCF_write].addr)
               (fd, buf, nbytes);
#if defined(HAVE_SYSCALL) && defined(SYS_write)
    else return (ssize_t)syscall(SYS_write, fd, buf, nbytes);
#else
    else PTH_SYSCALL_ERROR(-1, ENOSYS, "write");
#endif
}
/* ==== Pth hard syscall wrapper for readv(2) ==== */
ssize_t readv(int, const struct iovec *, int);
ssize_t readv(int fd, const struct iovec *iov, int iovcnt)
{
    /* external entry point for application */
    pth_implicit_init();
    return pth_readv(fd, iov, iovcnt);
}
intern ssize_t pth_sc_readv(int fd, const struct iovec *iov, int iovcnt)
{
    /* internal exit point for Pth */
    if (pth_syscall_fct_tab[PTH_SCF_readv].addr != NULL)
        return ((ssize_t (*)(int, const struct iovec *, int))
               pth_syscall_fct_tab[PTH_SCF_readv].addr)
               (fd, iov, iovcnt);
#if defined(HAVE_SYSCALL) && defined(SYS_readv)
    else return (ssize_t)syscall(SYS_readv, fd, iov, iovcnt);
#else
    else PTH_SYSCALL_ERROR(-1, ENOSYS, "readv");
#endif
}
/* ==== Pth hard syscall wrapper for writev(2) ==== */
ssize_t writev(int, const struct iovec *, int);
ssize_t writev(int fd, const struct iovec *iov, int iovcnt)
{
    /* external entry point for application */
    pth_implicit_init();
    return pth_writev(fd, iov, iovcnt);
}
intern ssize_t pth_sc_writev(int fd, const struct iovec *iov, int iovcnt)
{
    /* internal exit point for Pth */
    if (pth_syscall_fct_tab[PTH_SCF_writev].addr != NULL)
        return ((ssize_t (*)(int, const struct iovec *, int))
               pth_syscall_fct_tab[PTH_SCF_writev].addr)
               (fd, iov, iovcnt);
#if defined(HAVE_SYSCALL) && defined(SYS_writev)
    else return (ssize_t)syscall(SYS_writev, fd, iov, iovcnt);
#else
    else PTH_SYSCALL_ERROR(-1, ENOSYS, "writev");
#endif
}
/* ==== Pth hard syscall wrapper for pread(2) ==== */
ssize_t pread(int, void *, size_t, off_t);
ssize_t pread(int fd, void *buf, size_t nbytes, off_t offset)
{
    /* external entry point for application */
    pth_implicit_init();
    return pth_pread(fd, buf, nbytes, offset);
}
/* NOTICE: internally fully emulated, so still no
   internal exit point pth_sc_pread necessary! */
/* ==== Pth hard syscall wrapper for pwrite(2) ==== */
ssize_t pwrite(int, const void *, size_t, off_t);
ssize_t pwrite(int fd, const void *buf, size_t nbytes, off_t offset)
{
    /* external entry point for application */
    pth_implicit_init();
    return pth_pwrite(fd, buf, nbytes, offset);
}
/* NOTICE: internally fully emulated, so still no
   internal exit point pth_sc_pwrite necessary! */
/* ==== Pth hard syscall wrapper for recv(2) ==== */
ssize_t recv(int, void *, size_t, int);
ssize_t recv(int fd, void *buf, size_t nbytes, int flags)
{
    /* external entry point for application */
    pth_implicit_init();
    return pth_recv(fd, buf, nbytes, flags);
}
intern ssize_t pth_sc_recv(int fd, void *buf, size_t nbytes, int flags)
{
    /* internal exit point for Pth */
    if (pth_syscall_fct_tab[PTH_SCF_recv].addr != NULL)
        return ((ssize_t (*)(int, void *, size_t, int))
               pth_syscall_fct_tab[PTH_SCF_recv].addr)
               (fd, buf, nbytes, flags);
#if defined(HAVE_SYSCALL) && defined(SYS_recv)
    else return (ssize_t)syscall(SYS_recv, fd, buf, nbytes, flags);
#elif defined(HAVE_SYSCALL) && defined(SYS_recvfrom)
    else return (ssize_t)syscall(SYS_recvfrom, fd, buf, nbytes, flags, (struct sockaddr *)NULL, (socklen_t *)NULL);
#else
    else PTH_SYSCALL_ERROR(-1, ENOSYS, "recv");
#endif
}
/* ==== Pth hard syscall wrapper for send(2) ==== */
ssize_t send(int, void *, size_t, int);
ssize_t send(int fd, void *buf, size_t nbytes, int flags)
{
    /* external entry point for application */
    pth_implicit_init();
    return pth_send(fd, buf, nbytes, flags);
}
intern ssize_t pth_sc_send(int fd, void *buf, size_t nbytes, int flags)
{
    /* internal exit point for Pth */
    if (pth_syscall_fct_tab[PTH_SCF_send].addr != NULL)
        return ((ssize_t (*)(int, void *, size_t, int))
               pth_syscall_fct_tab[PTH_SCF_send].addr)
               (fd, buf, nbytes, flags);
#if defined(HAVE_SYSCALL) && defined(SYS_send)
    else return (ssize_t)syscall(SYS_send, fd, buf, nbytes, flags);
#elif defined(HAVE_SYSCALL) && defined(SYS_sendto)
    else return (ssize_t)syscall(SYS_sendto, fd, buf, nbytes, flags, (struct sockaddr *)NULL, 0);
#else
    else PTH_SYSCALL_ERROR(-1, ENOSYS, "send");
#endif
}
/* ==== Pth hard syscall wrapper for recvfrom(2) ==== */
ssize_t recvfrom(int, void *, size_t, int, struct sockaddr *, socklen_t *);
ssize_t recvfrom(int fd, void *buf, size_t nbytes, int flags, struct sockaddr *from, socklen_t *fromlen)
{
    /* external entry point for application */
    pth_implicit_init();
    return pth_recvfrom(fd, buf, nbytes, flags, from, fromlen);
}
intern ssize_t pth_sc_recvfrom(int fd, void *buf, size_t nbytes, int flags, struct sockaddr *from, socklen_t *fromlen)
{
    /* internal exit point for Pth */
    if (pth_syscall_fct_tab[PTH_SCF_recvfrom].addr != NULL)
        return ((ssize_t (*)(int, void *, size_t, int, struct sockaddr *, socklen_t *))
               pth_syscall_fct_tab[PTH_SCF_recvfrom].addr)
               (fd, buf, nbytes, flags, from, fromlen);
#if defined(HAVE_SYSCALL) && defined(SYS_recvfrom)
    else return (ssize_t)syscall(SYS_recvfrom, fd, buf, nbytes, flags, from, fromlen);
#else
    else PTH_SYSCALL_ERROR(-1, ENOSYS, "recvfrom");
#endif
}
/* ==== Pth hard syscall wrapper for sendto(2) ==== */
ssize_t sendto(int, const void *, size_t, int, const struct sockaddr *, socklen_t);
ssize_t sendto(int fd, const void *buf, size_t nbytes, int flags, const struct sockaddr *to, socklen_t tolen)
{
    /* external entry point for application */
    pth_implicit_init();
    return pth_sendto(fd, buf, nbytes, flags, to, tolen);
}
intern ssize_t pth_sc_sendto(int fd, const void *buf, size_t nbytes, int flags, const struct sockaddr *to, socklen_t tolen)
{
    /* internal exit point for Pth */
    if (pth_syscall_fct_tab[PTH_SCF_sendto].addr != NULL)
        return ((ssize_t (*)(int, const void *, size_t, int, const struct sockaddr *, socklen_t))
               pth_syscall_fct_tab[PTH_SCF_sendto].addr)
               (fd, buf, nbytes, flags, to, tolen);
#if defined(HAVE_SYSCALL) && defined(SYS_sendto)
    else return (ssize_t)syscall(SYS_sendto, fd, buf, nbytes, flags, to, tolen);
#else
    else PTH_SYSCALL_ERROR(-1, ENOSYS, "sendto");
#endif
}
#endif /* PTH_SYSCALL_HARD */
#define PTH_TCB_NAMELEN 40
    /* thread control block */
struct pth_st {
    /* priority queue handling */
    pth_t          q_next;               /* next thread in pool                         */
    pth_t          q_prev;               /* previous thread in pool                     */
    int            q_prio;               /* (relative) priority of thread when queued   */
    /* standard thread control block ingredients */
    int            prio;                 /* base priority of thread                     */
    char           name[PTH_TCB_NAMELEN];/* name of thread (mainly for debugging)       */
    int            dispatches;           /* total number of thread dispatches           */
    pth_state_t    state;                /* current state indicator for thread          */
    /* timing */
    pth_time_t     spawned;              /* time point at which thread was spawned      */
    pth_time_t     lastran;              /* time point at which thread was last running */
    pth_time_t     running;              /* time range the thread was already running   */
    /* event handling */
    pth_event_t    events;               /* events the tread is waiting for             */
    /* per-thread signal handling */
    sigset_t       sigpending;           /* set    of pending signals                   */
    int            sigpendcnt;           /* number of pending signals                   */
    /* machine context */
    pth_mctx_t     mctx;                 /* last saved machine state of thread          */
    char          *stack;                /* pointer to thread stack                     */
    unsigned int   stacksize;            /* size of thread stack                        */
    long          *stackguard;           /* stack overflow guard                        */
    int            stackloan;            /* stack type                                  */
    void        *(*start_func)(void *);  /* start routine                               */
    void          *start_arg;            /* start argument                              */
    /* thread joining */
    int            joinable;             /* whether thread is joinable                  */
    void          *join_arg;             /* joining argument                            */
    /* per-thread specific storage */
    const void   **data_value;           /* thread specific  values                     */
    int            data_count;           /* number of stored values                     */
    /* cancellation support */
    int            cancelreq;            /* cancellation request is pending             */
    unsigned int   cancelstate;          /* cancellation state of thread                */
    pth_cleanup_t *cleanups;             /* stack of thread cleanup handlers            */
    /* mutex ring */
    pth_ring_t     mutexring;            /* ring of aquired mutex structures            */
#ifdef PTH_EX
    /* per-thread exception handling */
    ex_ctx_t       ex_ctx;               /* exception handling context                  */
#endif
};
#define PTH_TIME_NOW  (pth_time_t *)(0)
#define PTH_TIME_ZERO &pth_time_zero
#define pth_time_equal(t1,t2) \
        (((t1).tv_sec == (t2).tv_sec) && ((t1).tv_usec == (t2).tv_usec))
#if defined(HAVE_GETTIMEOFDAY_ARGS1)
#define __gettimeofday(t) gettimeofday(t)
#else
#define __gettimeofday(t) gettimeofday(t, NULL)
#endif
#define pth_time_set(t1,t2) \
    do { \
        if ((t2) == PTH_TIME_NOW) \
            __gettimeofday((t1)); \
        else { \
            (t1)->tv_sec  = (t2)->tv_sec; \
            (t1)->tv_usec = (t2)->tv_usec; \
        } \
    } while (0)
#define pth_time_add(t1,t2) \
    (t1)->tv_sec  += (t2)->tv_sec; \
    (t1)->tv_usec += (t2)->tv_usec; \
        (t1)->tv_sec  += 1; \
        (t1)->tv_usec -= 1000000; \
    }
#endif
/* calculate: t1 = t1 - t2 */
#define pth_time_sub(t1,t2) \
    (t1)->tv_sec  -= (t2)->tv_sec; \
    (t1)->tv_usec -= (t2)->tv_usec; \
        (t1)->tv_sec  -= 1; \
        (t1)->tv_usec += 1000000; \
    }
#endif
/* calculate: t1 = t1 / n */
intern void pth_time_div(pth_time_t *t1, int n)
{
    long q, r;
    q = (t1->tv_sec / n);
    r = (((t1->tv_sec % n) * 1000000) / n) + (t1->tv_usec / n);
        q += 1;
        r -= 1000000;
    }
    t1->tv_sec  = q;
    t1->tv_usec = r;
    return;
}
/* calculate: t1 = t1 * n */
intern void pth_time_mul(pth_time_t *t1, int n)
{
    t1->tv_sec  *= n;
    t1->tv_usec *= n;
    t1->tv_sec  += (t1->tv_usec / 1000000);
    t1->tv_usec  = (t1->tv_usec % 1000000);
    return;
}
/* convert a time structure into a double value */
intern double pth_time_t2d(pth_time_t *t)
{
    double d;
    d = ((double)t->tv_sec*1000000 + (double)t->tv_usec) / 1000000;
    return d;
}
/* convert a time structure into a integer value */
intern int pth_time_t2i(pth_time_t *t)
{
    int i;
    i = (t->tv_sec*1000000 + t->tv_usec) / 1000000;
    return i;
}
/* check whether time is positive */
intern int pth_time_pos(pth_time_t *t)
{
    if (t->tv_sec > 0 && t->tv_usec > 0)
        return 1;
    else
        return 0;
}
#define pth_util_min(a,b) \
        ((a) > (b) ? (b) : (a))
#endif
/* delete a pending signal */
static void pth_util_sigdelete_sighandler(int _sig)
{
    (void)_sig;
    /* nop */
    return;
}
intern int pth_util_sigdelete(int sig)
{
    sigset_t ss, oss;
    struct sigaction sa, osa;
    /* check status of signal */
    sigpending(&ss);
    if (!sigismember(&ss, sig))
        return FALSE;
    /* block signal and remember old mask */
    sigemptyset(&ss);
    sigaddset(&ss, sig);
    pth_sc(sigprocmask)(SIG_BLOCK, &ss, &oss);
    /* set signal action to our dummy handler */
    sa.sa_handler = pth_util_sigdelete_sighandler;
    sigfillset(&sa.sa_mask);
    sa.sa_flags = 0;
        pth_sc(sigprocmask)(SIG_SETMASK, &oss, NULL);
        return FALSE;
    }
    /* now let signal be delivered */
    sigfillset(&ss);
    sigdelset(&ss, sig);
    sigsuspend(&ss);
    /* restore signal mask and handler */
    sigaction(sig, &osa, NULL);
    pth_sc(sigprocmask)(SIG_SETMASK, &oss, NULL);
    return TRUE;
}
/* copy a string like strncpy() but always null-terminate */
intern char *pth_util_cpystrn(char *dst, const char *src, size_t dst_size)
{
    register char *d, *end;
    if (dst_size == 0)
        return dst;
    d = dst;
    end = dst + dst_size - 1;
        if ((*d = *src) == '\0')
            return d;
    }
    *d = '\0';
    return d;
}
/* check whether a file-descriptor is valid */
intern int pth_util_fd_valid(int fd)
{
    if (fd < 0 || fd >= FD_SETSIZE)
        return FALSE;
    if (fcntl(fd, F_GETFL) == -1 && errno == EBADF)
        return FALSE;
    return TRUE;
}
/* merge input fd set into output fds */
intern void pth_util_fds_merge(int nfd,
                               fd_set *ifds1, fd_set *ofds1,
                               fd_set *ifds2, fd_set *ofds2,
                               fd_set *ifds3, fd_set *ofds3)
{
    register int s;
        if (ifds1 != NULL)
            if (FD_ISSET(s, ifds1))
                FD_SET(s, ofds1);
        if (ifds2 != NULL)
            if (FD_ISSET(s, ifds2))
                FD_SET(s, ofds2);
        if (ifds3 != NULL)
            if (FD_ISSET(s, ifds3))
                FD_SET(s, ofds3);
    }
    return;
}
/* test whether fds in the input fd sets occurred in the output fds */
intern int pth_util_fds_test(int nfd,
                             fd_set *ifds1, fd_set *ofds1,
                             fd_set *ifds2, fd_set *ofds2,
                             fd_set *ifds3, fd_set *ofds3)
{
    register int s;
        if (ifds1 != NULL)
            if (FD_ISSET(s, ifds1) && FD_ISSET(s, ofds1))
                return TRUE;
        if (ifds2 != NULL)
            if (FD_ISSET(s, ifds2) && FD_ISSET(s, ofds2))
                return TRUE;
        if (ifds3 != NULL)
            if (FD_ISSET(s, ifds3) && FD_ISSET(s, ofds3))
                return TRUE;
    }
    return FALSE;
}
/*
 * clear fds in input fd sets if not occurred in output fd sets and return
 * number of remaining input fds. This number uses BSD select(2) semantics: a
 * fd in two set counts twice!
 */
intern int pth_util_fds_select(int nfd,
                               fd_set *ifds1, fd_set *ofds1,
                               fd_set *ifds2, fd_set *ofds2,
                               fd_set *ifds3, fd_set *ofds3)
{
    register int s;
    register int n;
    n = 0;
            if (!FD_ISSET(s, ofds1))
               FD_CLR(s, ifds1);
            else
               n++;
        }
            if (!FD_ISSET(s, ofds2))
                FD_CLR(s, ifds2);
            else
                n++;
        }
            if (!FD_ISSET(s, ofds3))
                FD_CLR(s, ifds3);
            else
                n++;
        }
    }
    return n;
}
